{"version":3,"sources":["gameMechanics/textures/texturePack.ts","gameMechanics/textures/textureEngine.ts","gameMechanics/gameObjects/AbstractGameObject.ts","gameMechanics/textures/AnimatedTexture.ts","gameMechanics/gameObjects/Player.tsx","gameMechanics/gameObjects/Chunk.tsx","gameMechanics/Scene.ts","keyBindings.ts","gameMechanics/network/NetworkClient.ts","gameMechanics/gui/minimap.ts","gameMechanics/GameCore.tsx","App.tsx","serviceWorker.js","index.js"],"names":["textures","player","filename","width","animations","default","start","end","type","walking","inventory_opening","inventory_open","inventory_closing","equip","unequip","mine","eat","interact","resourceFiles","Object","values","map","texture","filter","v","i","indexOf","atlases","loaded","RESOURCES_LOCATION","createMaterial","scene","material","StandardMaterial","emissiveTexture","opacityTexture","AbstractGameObject","mesh","position","Vector2","Zero","this","deltaTime","visible","setEnabled","AnimatedTexture","textureAtlas","animation","animationQueue","frame","direction","interval","textureScale","t","Texture","NEAREST_NEAREST","uOffset","vOffset","uScale","vScale","hasAlpha","queueAnimation","setInterval","tick","window","length","unskipable","keys","includes","console","warn","push","skippable","framesCount","Math","abs","haveNextAnimation","shift","newAnimation","animationDir","error","Player","id","velocityX","velocityY","targetX","targetY","finalVelocityX","finalVelocityY","targetTime","keyBindings","up","down","left","right","keysPressed","x","y","serialized","smooth","updateMesh","deltaTimeModified","movingX","movingY","diagonalModifier","sqrt","pow","keyCode","key","newBindings","MeshBuilder","CreatePlane","height","sideOrientation","Mesh","FRONTSIDE","getTexture","title","Vector3","titleTexture","DynamicTexture","BILINEAR_SAMPLINGMODE","ctx","getContext","fillStyle","fillRect","getSize","font","textBaseline","textAlign","fillText","update","parent","isLast","Chunk","ground","getTerrainColor","getId","toString","number","GameScene","players","IndexedList","chunks","forEach","value","deserialize","newObjectCreator","callbackfn","index","result","assign","CONTROLS_WASD","NetworkClient","apiUrl","getBabylonScene","socket","userId","opened","callbacks","authenticated","updated","event","callback","disconnect","io","setListeners","on","data","log","emit","content","serialize","get","setVisibility","updateOrCreate","attachBabylon","getTile","calcX","floor","calcY","chunkX","chunkY","chunk","GameCore","props","gameScene","me","babylonScene","guiTexture","networkClient","state","timer","initGame","document","addEventListener","keyDown","keyUp","resize","open","clearInterval","close","bindKeys","add","sendPlayerUpdate","round","chunkId","requestChunk","gui","clearRect","x0","MINIMAP_SCALE","y0","minimap","canvas","getElementById","innerWidth","innerHeight","camera","UniversalCamera","rotation","AdvancedDynamicTexture","CreateFullscreenUI","getEngine","runRenderLoop","getDeltaTime","render","antialias","canvasId","onSceneMount","React","Component","App","status","of","onLoad","onStateChange","setState","Image","onload","onerror","src","style","Boolean","location","hostname","match","ReactDOM","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.cc5ae2ce.chunk.js","sourcesContent":["import { texturePack } from './textureEngine';\n\nexport const textures: texturePack = {\n    player: {\n        filename: 'Character.png',\n        width: 57,\n        animations: {\n            default: {\n                start: 0,\n                end: 0,\n                type: 'frame',\n            },\n            walking: {\n                start: 0,\n                end: 7,\n                type: 'loop',\n            },\n            inventory_opening: {\n                start: 8,\n                end: 11,\n                type: 'once',\n            },\n            inventory_open: {\n                start: 11,\n                end: 11,\n                type: 'frame',\n            },\n            inventory_closing: {\n                start: 11,\n                end: 8,\n                type: 'once',\n            },\n            equip: {\n                start: 12,\n                end: 19,\n                type: 'once',\n            },\n            unequip: {\n                start: 19,\n                end: 12,\n                type: 'once',\n            },\n            mine: {\n                start: 20,\n                end: 22,\n                type: 'boomerang',\n            },\n            eat: {\n                start: 23,\n                end: 51,\n                type: 'once',\n            },\n            interact: {\n                start: 52,\n                end: 56,\n                type: 'once',\n            },\n        },\n    },\n};\n","import { Texture, Scene, StandardMaterial } from '@babylonjs/core';\nimport { textures } from './texturePack';\n\nexport interface texturePack {\n    [name: string]: {\n        filename: string;\n        width: number;\n        animations: { [name: string]: { start: number; end: number; type: 'loop' | 'once' | 'boomerang' | 'frame' } };\n    };\n}\n\nlet resourceFiles = Object.values(textures).map((texture) => texture.filename);\nresourceFiles = resourceFiles.filter((v, i) => resourceFiles.indexOf(v) === i);\n\nlet atlases: { [key: string]: HTMLImageElement } = {};\n\nlet loaded = 0;\n\nexport const RESOURCES_LOCATION = '/randomgame/resources/textures/';\n\nexport function loadTextures(onLoad: () => void, onStateChange?: (loaded: number, of: number) => void) {\n    if (resourceFiles.length === 0) {\n        onStateChange && onStateChange(0, resourceFiles.length);\n        onLoad();\n    }\n\n    resourceFiles.forEach((filename) => {\n        atlases[filename] = new Image();\n        atlases[filename].onload = () => {\n            loaded++;\n            onStateChange && onStateChange(loaded, resourceFiles.length);\n\n            if (loaded === resourceFiles.length) {\n                onLoad();\n            }\n        };\n        atlases[filename].onerror = () => {\n            console.error('Error loading resource file: ', filename);\n        };\n        atlases[filename].src = RESOURCES_LOCATION + filename;\n    });\n\n    return resourceFiles.length;\n}\n\nexport function createTexture(texture: string, scene: Scene) {\n    const t = new Texture(RESOURCES_LOCATION + textures[texture].filename, scene, false, true, Texture.NEAREST_NEAREST);\n    t.uOffset = 0;\n    t.vOffset = 0;\n    t.uScale = 1 / textures[texture].width;\n    t.vScale = 1;\n    t.hasAlpha = true;\n    return t;\n}\n\nexport function createMaterial(texture: Texture, scene: Scene) {\n    const material = new StandardMaterial('mat', scene);\n    material.emissiveTexture = texture;\n    material.opacityTexture = texture;\n\n    return material;\n}\n","import { Mesh, Vector2, Scene } from '@babylonjs/core';\r\n\r\nexport abstract class AbstractGameObject {\r\n    protected scene: Scene | null = null;\r\n    protected mesh: Mesh | null = null;\r\n    public position: Vector2 = Vector2.Zero();\r\n\r\n    attachBabylon(scene: Scene): AbstractGameObject {\r\n        this.scene = scene;\r\n\r\n        return this;\r\n    }\r\n\r\n    abstract serialize(): any;\r\n\r\n    abstract deserialize(serialized: any): void;\r\n\r\n    tick(deltaTime: number): void {}\r\n\r\n    abstract async updateMesh(): Promise<void>;\r\n\r\n    setVisibility(visible: boolean) {\r\n        if (this.mesh) this.mesh.setEnabled(visible);\r\n    }\r\n\r\n    abstract get id(): string;\r\n}\r\n","import { Texture, Scene } from '@babylonjs/core';\nimport { textures } from './texturePack';\nimport { RESOURCES_LOCATION } from './textureEngine';\n\nconst TIME_PER_FRAME = 80;\n\nexport class AnimatedTexture {\n    private textureAtlas: string;\n    private texture: Texture;\n    private animationQueue: { texture: string; skippable: boolean }[] = [];\n    private frame: number = 0;\n    private direction: number = 1;\n    private interval: NodeJS.Timeout;\n\n    private textureScale = 1;\n\n    constructor(textureAtlas: string, scene: Scene, animation: string = 'default') {\n        this.textureAtlas = textureAtlas;\n        this.textureScale = 1 / textures[textureAtlas].width;\n\n        const t = new Texture(\n            RESOURCES_LOCATION + textures[textureAtlas].filename,\n            scene,\n            false,\n            true,\n            Texture.NEAREST_NEAREST,\n        );\n        t.uOffset = this.textureScale * textures[textureAtlas].animations[animation].start;\n        t.vOffset = 0;\n        t.uScale = this.textureScale;\n        t.vScale = 1;\n        t.hasAlpha = true;\n\n        this.texture = t;\n\n        this.queueAnimation(animation);\n        this.interval = setInterval(() => this.tick(), TIME_PER_FRAME);\n\n        (window as any).texture = this;\n    }\n\n    getTexture() {\n        return this.texture;\n    }\n\n    isLast(animation: string) {\n        return this.animationQueue[this.animationQueue.length - 1].texture === animation;\n    }\n\n    queueAnimation(animation: string, unskipable?: boolean) {\n        if (!Object.keys(textures[this.textureAtlas].animations).includes(animation)) {\n            console.warn('Animation does not exist');\n            this.animationQueue.push({ texture: 'default', skippable: true });\n            return;\n        }\n\n        if (this.animationQueue.length > 1 && this.animationQueue[this.animationQueue.length - 1].skippable) {\n            this.animationQueue[this.animationQueue.length - 1] = { texture: animation, skippable: !unskipable };\n        } else {\n            this.animationQueue.push({ texture: animation, skippable: !unskipable });\n        }\n    }\n\n    tick() {\n        if (!this.texture) {\n            console.error('Texture is null');\n            return;\n        }\n\n        this.frame += this.direction;\n\n        const animation = textures[this.textureAtlas].animations[this.animationQueue[0].texture];\n        const framesCount = Math.abs(animation.start - animation.end);\n\n        const haveNextAnimation = this.animationQueue.length > 1;\n\n        if (this.frame > framesCount) {\n            // At the right end\n\n            switch (animation.type) {\n                case 'loop':\n                    this.direction = 1;\n                    this.frame = 0;\n                    if (haveNextAnimation) {\n                        this.animationQueue.shift();\n                    }\n                    break;\n                case 'once':\n                    this.direction = 1;\n                    if (haveNextAnimation) {\n                        this.frame = 0;\n                        this.animationQueue.shift();\n                    } else {\n                        this.frame = framesCount;\n                    }\n                    break;\n                case 'boomerang':\n                    this.direction = -1;\n                    this.frame -= 2;\n                    break;\n                case 'frame':\n                    this.direction = 1;\n                    this.frame = 0;\n                    if (haveNextAnimation) {\n                        this.animationQueue.shift();\n                    }\n                    break;\n            }\n        }\n\n        if (this.frame < 0) {\n            // At the left end - Can happen just with boomerang\n            this.direction = 1;\n            if (haveNextAnimation) {\n                this.frame = 0;\n                this.animationQueue.shift();\n            } else {\n                this.frame = 0;\n            }\n        }\n\n        const newAnimation = textures[this.textureAtlas].animations[this.animationQueue[0].texture];\n        const animationDir = newAnimation.start > newAnimation.end ? -1 : 1;\n        this.texture.uOffset = (this.frame * animationDir + newAnimation.start) * this.textureScale;\n    }\n}\n","import { Vector3, Mesh, Scene, MeshBuilder, DynamicTexture, Texture } from '@babylonjs/core';\nimport { createMaterial } from '../textures/textureEngine';\nimport { AbstractGameObject } from './AbstractGameObject';\nimport { AnimatedTexture } from '../textures/AnimatedTexture';\n\nexport interface serializedPlayer {\n    x: number;\n    y: number;\n    velocityX: number;\n    velocityY: number;\n}\n\nexport interface keyBindings {\n    up: number;\n    down: number;\n    left: number;\n    right: number;\n}\n\nconst SPEED_CHANGE = 0.2;\nconst SLOWING = 0.95;\nconst MODIFIER = 0.1;\nconst SMOOTH_TIME = 50;\n\nexport class Player extends AbstractGameObject {\n    private velocityX: number = 0;\n    private velocityY: number = 0;\n\n    // SMOOTHING\n    private targetX: number = 0;\n    private targetY: number = 0;\n    private finalVelocityX: number = 0;\n    private finalVelocityY: number = 0;\n    private targetTime: number = -1;\n\n    private keyBindings: keyBindings = {\n        up: 0,\n        down: 0,\n        left: 0,\n        right: 0,\n    };\n    private keysPressed: number[] = [];\n\n    private texture: AnimatedTexture;\n\n    constructor(public id: string) {\n        super();\n    }\n\n    serialize(): serializedPlayer {\n        return {\n            x: this.position.x,\n            y: this.position.y,\n            velocityX: this.velocityX,\n            velocityY: this.velocityY,\n        };\n    }\n\n    deserialize(serialized: serializedPlayer, smooth?: boolean): void {\n        if (smooth) {\n            this.targetX = serialized.x;\n            this.targetY = serialized.y;\n            this.finalVelocityX = serialized.velocityX;\n            this.finalVelocityY = serialized.velocityY;\n            this.targetTime = SMOOTH_TIME;\n            this.velocityX = (serialized.x - this.position.x) / SMOOTH_TIME;\n            this.velocityY = (serialized.y - this.position.y) / SMOOTH_TIME;\n        } else {\n            this.position.x = serialized.x;\n            this.position.y = serialized.y;\n            this.velocityX = serialized.velocityX;\n            this.velocityY = serialized.velocityY;\n        }\n    }\n\n    tick(deltaTime: number) {\n        if (this.targetTime > 0) {\n            this.position.x += this.velocityX * deltaTime;\n            this.position.y += this.velocityY * deltaTime;\n            this.targetTime -= deltaTime;\n\n            if (this.targetTime <= 0) {\n                this.position.x = this.targetX;\n                this.position.y = this.targetY;\n                this.velocityX = this.finalVelocityX;\n                this.velocityY = this.finalVelocityY;\n            }\n\n            this.updateMesh();\n            return;\n        }\n\n        if (!this.keyBindings.up && !this.keyBindings.down && !this.keyBindings.left && !this.keyBindings.right) {\n            this.position.x += this.velocityX;\n            this.position.y += this.velocityY;\n\n            this.updateMesh();\n            return;\n        }\n\n        const deltaTimeModified = MODIFIER * deltaTime;\n\n        let movingX = false;\n        let movingY = false;\n\n        const diagonalModifier = Math.sqrt(2);\n\n        if (this.keysPressed.includes(this.keyBindings.left) || this.keysPressed.includes(this.keyBindings.right)) {\n            movingX = true;\n        }\n        if (this.keysPressed.includes(this.keyBindings.up) || this.keysPressed.includes(this.keyBindings.down)) {\n            movingY = true;\n        }\n\n        if (this.keysPressed.includes(this.keyBindings.left)) {\n            // Left\n            this.velocityX -= (SPEED_CHANGE * deltaTimeModified) / (movingY ? diagonalModifier : 1);\n        }\n        if (this.keysPressed.includes(this.keyBindings.right)) {\n            // Right\n            this.velocityX += (SPEED_CHANGE * deltaTimeModified) / (movingY ? diagonalModifier : 1);\n        }\n        if (this.keysPressed.includes(this.keyBindings.up)) {\n            // Up\n            this.velocityY -= (SPEED_CHANGE * deltaTimeModified) / (movingX ? diagonalModifier : 1);\n        }\n        if (this.keysPressed.includes(this.keyBindings.down)) {\n            // Down\n            this.velocityY += (SPEED_CHANGE * deltaTimeModified) / (movingX ? diagonalModifier : 1);\n        }\n\n        this.position.x += this.velocityX * deltaTimeModified;\n        this.position.y += this.velocityY * deltaTimeModified;\n\n        this.velocityX *= Math.pow(SLOWING, deltaTimeModified);\n        this.velocityY *= Math.pow(SLOWING, deltaTimeModified);\n\n        if (Math.abs(this.velocityX) < 0.1) {\n            this.velocityX = 0;\n        }\n        if (Math.abs(this.velocityY) < 0.1) {\n            this.velocityY = 0;\n        }\n\n        this.updateMesh();\n    }\n\n    // ========== CONTROLS ===========\n\n    keyDown(keyCode: number) {\n        if (!this.keysPressed.includes(keyCode)) {\n            this.keysPressed.push(keyCode);\n        }\n    }\n\n    keyUp(keyCode: number) {\n        if (this.keysPressed.includes(keyCode)) {\n            this.keysPressed = this.keysPressed.filter((key) => key !== keyCode);\n        }\n    }\n\n    bindKeys(newBindings: Partial<keyBindings>) {\n        this.keyBindings = { ...this.keyBindings, ...newBindings };\n    }\n\n    // ========== BABYLON ===========\n\n    attachBabylon(scene: Scene) {\n        super.attachBabylon(scene);\n\n        if (!this.scene) return this;\n\n        this.mesh = MeshBuilder.CreatePlane(\n            'player',\n            { width: 100, height: 200, sideOrientation: Mesh.FRONTSIDE },\n            this.scene,\n        );\n        this.texture = new AnimatedTexture('player', this.scene, 'default');\n        this.mesh.material = createMaterial(this.texture.getTexture(), this.scene);\n\n        // Player title\n        const title = MeshBuilder.CreatePlane(\n            'title',\n            { width: 120, height: 25, sideOrientation: Mesh.FRONTSIDE },\n            this.scene,\n        );\n        title.position = new Vector3(0, 110, -3);\n        const titleTexture = new DynamicTexture(\n            'titleTexture',\n            { width: 120, height: 25 },\n            this.scene,\n            true,\n            Texture.BILINEAR_SAMPLINGMODE,\n        );\n        const ctx = titleTexture.getContext();\n        ctx.fillStyle = '#000000AA';\n        ctx.fillRect(0, 0, titleTexture.getSize().width, titleTexture.getSize().height);\n        ctx.font = '18px Arial';\n        ctx.textBaseline = 'middle';\n        ctx.textAlign = 'center';\n        ctx.fillStyle = '#FFFFFF';\n        ctx.fillText(\n            this.id,\n            titleTexture.getSize().width / 2,\n            titleTexture.getSize().height / 2,\n            titleTexture.getSize().width - 20,\n        );\n        titleTexture.update();\n\n        title.parent = this.mesh;\n        title.material = createMaterial(titleTexture, this.scene);\n\n        this.updateMesh();\n\n        return this;\n    }\n\n    async updateMesh() {\n        if (!this.mesh) return;\n        this.mesh.position = new Vector3(this.position.x, -this.position.y, -1);\n\n        const WALKING_THRESHOLD = 1;\n        if (Math.abs(this.velocityX) > WALKING_THRESHOLD || Math.abs(this.velocityY) > WALKING_THRESHOLD) {\n            if (!this.texture.isLast('walking')) {\n                this.texture.queueAnimation('walking');\n            }\n        } else {\n            if (!this.texture.isLast('default')) {\n                this.texture.queueAnimation('default');\n            }\n        }\n    }\n}\n","import { Vector3, Mesh, Scene, MeshBuilder, StandardMaterial, Texture, DynamicTexture, Vector2 } from '@babylonjs/core';\r\nimport { AbstractGameObject } from './AbstractGameObject';\r\n\r\nexport type tileType = number;\r\n\r\nexport interface serializedChunk {\r\n    x: number;\r\n    y: number;\r\n    ground: tileType[][];\r\n}\r\n\r\nexport class Chunk extends AbstractGameObject {\r\n    ground: tileType[][] = [[]];\r\n\r\n    constructor(x: number, y: number) {\r\n        super();\r\n        this.position = new Vector2(x, y);\r\n    }\r\n\r\n    get id(): string {\r\n        return Chunk.getId(this.position.x, this.position.y);\r\n    }\r\n\r\n    serialize(): serializedChunk {\r\n        return {\r\n            x: this.position.x,\r\n            y: this.position.y,\r\n            ground: this.ground,\r\n        };\r\n    }\r\n\r\n    deserialize(serialized: serializedChunk): void {\r\n        this.position.x = serialized.x;\r\n        this.position.y = serialized.y;\r\n        this.ground = serialized.ground;\r\n\r\n        this.updateMesh();\r\n    }\r\n\r\n    static getId(x: number, y: number): string {\r\n        return x.toString() + 'x' + y.toString();\r\n    }\r\n\r\n    // ========== BABYLON ===========\r\n\r\n    attachBabylon(scene: Scene) {\r\n        super.attachBabylon(scene);\r\n\r\n        this.mesh = MeshBuilder.CreatePlane(\r\n            'chunk',\r\n            { width: 1600, height: 1600, sideOrientation: Mesh.FRONTSIDE },\r\n            this.scene,\r\n        );\r\n        this.updateMesh();\r\n\r\n        return this;\r\n    }\r\n\r\n    async updateMesh() {\r\n        if (!this.mesh || !this.scene) {\r\n            return;\r\n        }\r\n\r\n        this.mesh.position = new Vector3(this.position.x * 16 * 100, -this.position.y * 16 * 100, 0);\r\n\r\n        const texture = new DynamicTexture(\r\n            'chunkTexture',\r\n            { width: 1 * 16, height: 1 * 16 },\r\n            this.scene,\r\n            true,\r\n            Texture.NEAREST_NEAREST,\r\n        );\r\n\r\n        const ctx = texture.getContext();\r\n\r\n        for (let x = 0; x < 16; x++) {\r\n            for (let y = 0; y < 16; y++) {\r\n                if (this.ground[x] && this.ground[x][y]) {\r\n                    ctx.fillStyle = Chunk.getTerrainColor(this.ground[x][y]);\r\n\r\n                    ctx.fillRect(x, y, 1, 1);\r\n                    if ((x + y) % 2 === 0) {\r\n                        ctx.fillStyle = '#00000005';\r\n                        ctx.fillRect(x, y, 1, 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        texture.update();\r\n\r\n        const material = new StandardMaterial('mat', this.scene);\r\n        material.emissiveTexture = texture;\r\n        this.mesh.material = material;\r\n    }\r\n\r\n    static getTerrainColor(number: number): string {\r\n        switch (number) {\r\n            case 1: // Grass\r\n                return '#CFDA78';\r\n            case 2: // Water\r\n                return '#4EDCF0';\r\n            case 3: // Forrest\r\n                return '#6AA981';\r\n            case 4: // Sand\r\n                return '#FDDC86';\r\n        }\r\n        return '#DDDDDD';\r\n    }\r\n}\r\n","import { Player } from './gameObjects/Player';\r\nimport { Chunk } from './gameObjects/Chunk';\r\n\r\nexport class GameScene {\r\n    players = new IndexedList<Player>();\r\n    chunks = new IndexedList<Chunk>();\r\n\r\n    tickAll(deltaTime: number) {\r\n        this.players.forEach((value) => value.tick(deltaTime));\r\n        this.chunks.forEach((value) => value.tick(deltaTime));\r\n    }\r\n}\r\n\r\nclass IndexedList<T extends Player | Chunk> {\r\n    values: { [key: string]: T } = {};\r\n\r\n    add(key: string, value: T) {\r\n        this.values[key] = value;\r\n    }\r\n\r\n    remove(key: string) {\r\n        if (!this.includes(key)) return;\r\n        delete this.values[key];\r\n    }\r\n\r\n    update(key: string, serialized: any, smooth?: boolean) {\r\n        this.values[key].deserialize(serialized, smooth);\r\n    }\r\n\r\n    updateOrCreate(key: string, serialized: any, newObjectCreator: () => T, smooth?: boolean) {\r\n        if (!this.includes(key)) {\r\n            this.values[key] = newObjectCreator();\r\n        }\r\n        this.values[key].deserialize(serialized, smooth);\r\n    }\r\n\r\n    get(key: string) {\r\n        if (!this.includes(key)) return null;\r\n        return this.values[key];\r\n    }\r\n\r\n    includes(key: string) {\r\n        return Object.keys(this.values).includes(key);\r\n    }\r\n\r\n    forEach(callbackfn: (value: T, key: string, index: number) => void) {\r\n        const keys = Object.keys(this.values);\r\n\r\n        keys.forEach((key, index) => {\r\n            callbackfn(this.values[key], key, index);\r\n        });\r\n    }\r\n\r\n    filter(callbackfn: (value: T, key: string, index: number) => boolean) {\r\n        const keys = Object.keys(this.values);\r\n\r\n        let result = Object.assign({}, this.values);\r\n\r\n        keys.forEach((key, index) => {\r\n            if (!callbackfn(this.values[key], key, index)) {\r\n                delete result[key];\r\n            }\r\n        });\r\n\r\n        return result;\r\n    }\r\n}\r\n","import { keyBindings } from './gameMechanics/gameObjects/Player';\r\n\r\n// ARROWS\r\nexport const CONTROLS_ARROWS: keyBindings = {\r\n    left: 37,\r\n    right: 39,\r\n    up: 38,\r\n    down: 40,\r\n};\r\n\r\n// WASD\r\nexport const CONTROLS_WASD: keyBindings = {\r\n    left: 65,\r\n    right: 68,\r\n    up: 87,\r\n    down: 83,\r\n};\r\n","import io from 'socket.io-client';\r\nimport { Player } from '../gameObjects/Player';\r\nimport { GameScene } from '../Scene';\r\nimport { messagePlayers } from '../../messageTypes';\r\nimport babylonjs from '@babylonjs/core';\r\nimport { serializedChunk, Chunk } from '../gameObjects/Chunk';\r\n\r\ntype callback = (data: any) => void;\r\n\r\nexport class NetworkClient {\r\n    private socket: SocketIOClient.Socket;\r\n    private userId: string;\r\n    private opened: boolean;\r\n    private callbacks: { [key: string]: callback } = {\r\n        authenticated: () => {},\r\n        updated: () => {},\r\n    };\r\n\r\n    constructor(private apiUrl: string, private scene: GameScene, private getBabylonScene: () => babylonjs.Scene) {}\r\n\r\n    public on(event: 'authenticated' | 'updated', callback: callback) {\r\n        this.callbacks[event] = callback;\r\n    }\r\n\r\n    public close() {\r\n        this.socket.disconnect();\r\n    }\r\n\r\n    public open() {\r\n        this.opened = true;\r\n        this.socket = io(this.apiUrl);\r\n        this.setListeners();\r\n\r\n        this.socket.on('id', (data: string) => {\r\n            this.userId = data;\r\n            this.callbacks['authenticated']({ id: data });\r\n            console.log('Joined game with player ID: ', data);\r\n        });\r\n    }\r\n\r\n    public sendPlayerUpdate(player: Player) {\r\n        this.socket.emit('update', { id: player.id, content: player.serialize() });\r\n    }\r\n\r\n    public requestChunk(x: number, y: number) {\r\n        this.socket.emit('mapRequest', { x, y });\r\n    }\r\n\r\n    private setListeners() {\r\n        this.socket.on('players', (data: messagePlayers) => {\r\n            this.scene.players.forEach((player, key) => {\r\n                if (!Object.keys(data).includes(key)) {\r\n                    this.scene.players.get(key)!.setVisibility(false);\r\n                } else {\r\n                    this.scene.players.get(key)!.setVisibility(true);\r\n                }\r\n            });\r\n\r\n            Object.keys(data).forEach((key) => {\r\n                if (key === this.userId) {\r\n                    return;\r\n                }\r\n\r\n                this.scene.players.updateOrCreate(key, data[key], () =>\r\n                    new Player(key).attachBabylon(this.getBabylonScene()),\r\n                );\r\n            });\r\n        });\r\n\r\n        this.socket.on('mapChunk', (data: serializedChunk) => {\r\n            const id = Chunk.getId(data.x, data.y);\r\n\r\n            this.scene.chunks.updateOrCreate(id, data, () =>\r\n                new Chunk(data.x, data.y).attachBabylon(this.getBabylonScene()),\r\n            );\r\n            // TODO: throw away unused chunks\r\n        });\r\n    }\r\n}\r\n","import { Chunk } from '../gameObjects/Chunk';\nimport { AdvancedDynamicTexture } from '@babylonjs/gui/2D/advancedDynamicTexture';\nimport { GameScene } from '../Scene';\nimport { Player } from '../gameObjects/Player';\n\nconst MINIMAP_DISTANCE = 32;\nconst MINIMAP_SCALE = 2;\nconst BORDER_WIDTH = 3;\n\nexport function minimap(guiTexture: AdvancedDynamicTexture, gameScene: GameScene, me: Player) {\n    const gui = guiTexture.getContext();\n    const width = guiTexture.getSize().width;\n    const height = guiTexture.getSize().height;\n\n    const x0 = width - 30 - MINIMAP_SCALE * MINIMAP_DISTANCE;\n    const y0 = 20 + MINIMAP_SCALE * MINIMAP_DISTANCE;\n\n    gui.fillStyle = '#000000';\n    gui.fillRect(\n        x0 - MINIMAP_SCALE * MINIMAP_DISTANCE - BORDER_WIDTH,\n        y0 - MINIMAP_SCALE * MINIMAP_DISTANCE - BORDER_WIDTH,\n        MINIMAP_SCALE * MINIMAP_DISTANCE * 2 + BORDER_WIDTH * 2 + MINIMAP_SCALE,\n        MINIMAP_SCALE * MINIMAP_DISTANCE * 2 + BORDER_WIDTH * 2 + MINIMAP_SCALE,\n    );\n\n    for (let x = -MINIMAP_DISTANCE; x <= MINIMAP_DISTANCE; x++) {\n        for (let y = -MINIMAP_DISTANCE; y <= MINIMAP_DISTANCE; y++) {\n            gui.fillStyle = Chunk.getTerrainColor(getTile(me.position.x / 100 + x, me.position.y / 100 + y, gameScene));\n            gui.fillRect(x0 + x * MINIMAP_SCALE, y0 + y * MINIMAP_SCALE, MINIMAP_SCALE, MINIMAP_SCALE);\n        }\n    }\n\n    gui.fillStyle = \"#000000\";\n    gui.font = '15px Arial';\n    gui.textBaseline = 'top';\n    gui.textAlign = 'center';\n    gui.fillText(\n        me\n            ? Math.round(me.position.x / 100) + ' × ' + Math.round(me.position.y / 100)\n            : 'Not connected...',\n        x0,\n        y0 + MINIMAP_SCALE * MINIMAP_DISTANCE + BORDER_WIDTH + 10,\n    );\n    \n    gui.fillStyle = \"#00000020\";\n    gui.fillRect(x0 - MINIMAP_SCALE * 3, y0, MINIMAP_SCALE * 7, MINIMAP_SCALE);\n    gui.fillRect(x0, y0 - MINIMAP_SCALE * 3, MINIMAP_SCALE, MINIMAP_SCALE * 7);\n\n    guiTexture.update();\n}\n\nfunction getTile(x: number, y: number, scene: GameScene) {\n    const calcX = Math.floor(x) + 8;\n    const calcY = Math.floor(y) + 8;\n\n    const chunkX = Math.floor(calcX / 16);\n    const chunkY = Math.floor(calcY / 16);\n    const chunk = scene.chunks.get(Chunk.getId(chunkX, chunkY));\n\n    if (!chunk || !chunk.ground[calcX - chunkX * 16] || !chunk.ground[calcX - chunkX * 16][calcY - chunkY * 16]) {\n        return -1;\n    }\n\n    return chunk.ground[calcX - chunkX * 16][calcY - chunkY * 16];\n}","import React from 'react';\n\nimport '@babylonjs/core/Physics/physicsEngineComponent';\nimport babylonjs, { Vector3, UniversalCamera, Texture } from '@babylonjs/core';\nimport { Scene, Engine, SceneEventArgs } from 'react-babylonjs';\n\nimport { AdvancedDynamicTexture } from '@babylonjs/gui/2D/advancedDynamicTexture';\nimport { Player } from './gameObjects/Player';\nimport { Chunk } from './gameObjects/Chunk';\nimport { GameScene } from './Scene';\nimport { CONTROLS_WASD } from '../keyBindings';\nimport { NetworkClient } from './network/NetworkClient';\nimport { minimap } from './gui/minimap';\n\nconst Z_DISTANCE = 1500;\nconst RENDER_DISTANCE = 2;\n\ninterface IGameCoreProps {\n    apiUrl: string;\n}\n\ninterface IGameCoreState {}\n\nexport class GameCore extends React.Component<IGameCoreProps, IGameCoreState> {\n    gameScene: GameScene;\n    me: Player | null = null;\n\n    babylonScene: babylonjs.Scene | null;\n    guiTexture: AdvancedDynamicTexture | null;\n    networkClient: NetworkClient;\n    state: IGameCoreState = {};\n\n    timer: NodeJS.Timeout;\n\n    constructor(props: IGameCoreProps) {\n        super(props);\n\n        this.gameScene = new GameScene();\n        this.networkClient = new NetworkClient(this.props.apiUrl, this.gameScene, () => this.babylonScene!);\n        this.networkClient.on('authenticated', (data: { id: string }) => this.initGame(data.id));\n\n        document.addEventListener('keydown', (event) => {\n            if (this.me) {\n                this.me.keyDown(event.keyCode);\n            }\n        });\n\n        document.addEventListener('keyup', (event) => {\n            if (this.me) {\n                this.me.keyUp(event.keyCode);\n            }\n        });\n\n        window.addEventListener('resize', (event) => {\n            this.resize();\n        });\n    }\n\n    componentDidMount() {\n        this.resize();\n        this.networkClient.open();\n    }\n\n    componentWillUnmount() {\n        clearInterval(this.timer);\n        this.networkClient.close();\n    }\n\n    initGame(id: string) {\n        this.me = new Player(id);\n        this.me.attachBabylon(this.babylonScene!);\n        this.me.bindKeys(CONTROLS_WASD);\n        this.gameScene.players.add(id, this.me);\n\n        (window as any).player = this.me;\n        (window as any).scene = this.gameScene;\n\n        this.timer = setInterval(() => {\n            if (this.me) this.networkClient.sendPlayerUpdate(this.me);\n        }, 100);\n    }\n\n    tick(deltaTime: number) {\n        this.gameScene.players.forEach((player) => player.tick(deltaTime));\n\n        this.gameScene.chunks.forEach((chunk) => chunk.setVisibility(false));\n\n        if (this.me && this.guiTexture) {\n            for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {\n                for (let y = -RENDER_DISTANCE; y <= RENDER_DISTANCE; y++) {\n                    const chunkX = Math.round(this.me.position.x / 1600) + x;\n                    const chunkY = Math.round(this.me.position.y / 1600) + y;\n                    const chunkId = Chunk.getId(chunkX, chunkY);\n\n                    if (this.gameScene.chunks.includes(chunkId)) {\n                        this.gameScene.chunks.get(chunkId)!.setVisibility(true);\n                    } else {\n                        this.networkClient.requestChunk(chunkX, chunkY);\n                        this.gameScene.chunks.add(chunkId, new Chunk(chunkX, chunkY).attachBabylon(this.babylonScene!));\n                    }\n                }\n            }\n\n            const gui = this.guiTexture.getContext();\n            const width = this.guiTexture.getSize().width;\n            const height = this.guiTexture.getSize().height;\n            gui.clearRect(0, 0, width, height);\n\n            minimap(this.guiTexture, this.gameScene, this.me);\n\n            this.guiTexture.update();\n        }\n    }\n\n    resize() {\n        const canvas = document.getElementById('game') as HTMLCanvasElement;\n        if (canvas) {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n        }\n    }\n\n    onSceneMount(event: SceneEventArgs) {\n        const { scene } = event;\n\n        this.babylonScene = scene;\n\n        const camera = new UniversalCamera('Camera', new Vector3(0, 0, Z_DISTANCE), scene);\n        camera.rotation = new Vector3(0, 0, 0);\n        //camera.attachControl(event.canvas, true);\n\n        this.guiTexture = AdvancedDynamicTexture.CreateFullscreenUI('GUI', true, scene);\n\n        scene.getEngine().runRenderLoop(() => {\n            this.tick(scene.getEngine().getDeltaTime());\n\n            if (this.me) {\n                camera.position = new Vector3(this.me.position.x, -this.me.position.y, -Z_DISTANCE);\n            }\n\n            if (scene) {\n                scene.render();\n            }\n        });\n    }\n\n    render() {\n        return (\n            <>\n                <Engine antialias={true} canvasId=\"game\">\n                    <Scene onSceneMount={(event: SceneEventArgs) => this.onSceneMount(event)}>\n                        <></>\n                    </Scene>\n                </Engine>\n            </>\n        );\n    }\n}\n","import React from 'react';\r\nimport { GameCore } from './gameMechanics/GameCore';\r\nimport { loadTextures } from './gameMechanics/textures/textureEngine';\r\n\r\ninterface IAppProps {}\r\n\r\ninterface IAppState {\r\n    status: 'loading' | 'menu' | 'paused' | 'ingame';\r\n    textures: {\r\n        loaded: number;\r\n        of: number;\r\n    };\r\n}\r\n\r\nclass App extends React.Component<IAppProps, IAppState> {\r\n    //apiUrl = 'http://localhost:80/';\r\n    apiUrl = 'https://randombot-server.herokuapp.com/';\r\n\r\n    state: IAppState = {\r\n        status: 'loading',\r\n        textures: {\r\n            loaded: 0,\r\n            of: 0,\r\n        },\r\n    };\r\n\r\n    componentDidMount() {\r\n        this.setState({\r\n            textures: {\r\n                loaded: 0,\r\n                of: loadTextures(\r\n                    () => {\r\n                        this.setState({ status: 'ingame' });\r\n                    },\r\n                    (loaded, of) => {\r\n                        this.setState({\r\n                            textures: {\r\n                                loaded,\r\n                                of,\r\n                            },\r\n                        });\r\n                    },\r\n                ),\r\n            },\r\n        });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <>\r\n                {this.state.status === 'loading' && (\r\n                    <div style={{ textAlign: 'center' }}>\r\n                        Textures are loading ({this.state.textures.loaded}/{this.state.textures.of})\r\n                    </div>\r\n                )}\r\n                {this.state.status === 'ingame' && <GameCore apiUrl={this.apiUrl} />}\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}