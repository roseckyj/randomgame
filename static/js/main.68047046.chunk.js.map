{"version":3,"sources":["gameMechanics/textures/rexturePack.ts","gameMechanics/textures/textureEngine.ts","gameMechanics/gameObjects/AbstractGameObject.ts","gameMechanics/gameObjects/Player.tsx","gameMechanics/gameObjects/Chunk.tsx","gameMechanics/Scene.ts","keyBindings.ts","gameMechanics/network/NetworkClient.ts","gameMechanics/gui/minimap.ts","gameMechanics/GameCore.tsx","App.tsx","serviceWorker.js","index.js"],"names":["textures","grass_01","filename","corner","Vector2","size","grass_02","grass_03","player","resourceFiles","Object","values","map","texture","filter","v","i","indexOf","atlases","loaded","createMaterial","scene","material","StandardMaterial","emissiveTexture","opacityTexture","AbstractGameObject","mesh","position","Zero","this","deltaTime","visible","setEnabled","Player","id","velocityX","velocityY","targetX","targetY","finalVelocityX","finalVelocityY","targetTime","keyBindings","up","down","left","right","keysPressed","x","y","serialized","smooth","updateMesh","deltaTimeModified","movingX","movingY","diagonalModifier","Math","sqrt","includes","pow","abs","keyCode","push","key","newBindings","MeshBuilder","CreatePlane","width","height","sideOrientation","Mesh","FRONTSIDE","t","Texture","NEAREST_LINEAR","hasAlpha","createTexture","title","Vector3","titleTexture","DynamicTexture","ctx","getContext","fillStyle","fillRect","getSize","font","textBaseline","textAlign","fillText","update","parent","Chunk","ground","NEAREST_NEAREST","getTerrainColor","getId","toString","number","GameScene","players","IndexedList","chunks","forEach","value","tick","deserialize","newObjectCreator","keys","callbackfn","index","result","assign","CONTROLS_WASD","NetworkClient","apiUrl","getBabylonScene","socket","userId","opened","callbacks","authenticated","updated","event","callback","disconnect","io","setListeners","on","data","console","log","emit","content","serialize","get","setVisibility","updateOrCreate","attachBabylon","getTile","calcX","floor","calcY","chunkX","chunkY","chunk","GameCore","props","gameScene","me","babylonScene","guiTexture","networkClient","state","timer","initGame","document","addEventListener","keyDown","keyUp","window","resize","open","clearInterval","close","bindKeys","add","setInterval","sendPlayerUpdate","round","chunkId","requestChunk","gui","clearRect","x0","MINIMAP_SCALE","y0","minimap","canvas","getElementById","innerWidth","innerHeight","camera","UniversalCamera","rotation","AdvancedDynamicTexture","CreateFullscreenUI","getEngine","runRenderLoop","getDeltaTime","render","antialias","canvasId","onSceneMount","React","Component","App","status","of","onLoad","onStateChange","setState","Image","onload","length","onerror","error","src","style","Boolean","location","hostname","match","ReactDOM","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","message"],"mappings":"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","file":"static/js/main.68047046.chunk.js","sourcesContent":["import { Vector2 } from '@babylonjs/core';\r\nimport { texturePack } from './textureEngine';\r\n\r\nexport const textures: texturePack = {\r\n    grass_01: {\r\n        filename: 'HiddenThroughTime/buildings/Atlas_Egypt_Props_01.png',\r\n        corner: new Vector2(365, 1875),\r\n        size: new Vector2(85, 40),\r\n    },\r\n    grass_02: {\r\n        filename: 'HiddenThroughTime/buildings/Atlas_Egypt_Props_01.png',\r\n        corner: new Vector2(365, 1930),\r\n        size: new Vector2(85, 40),\r\n    },\r\n    grass_03: {\r\n        filename: 'HiddenThroughTime/buildings/Atlas_Egypt_Props_01.png',\r\n        corner: new Vector2(365, 1990),\r\n        size: new Vector2(85, 40),\r\n    },\r\n    player: {\r\n        filename: 'HiddenThroughTime/characters/Icon_Peasant_Man_9.png',\r\n        corner: new Vector2(0, 0),\r\n        size: new Vector2(79, 147),\r\n    },\r\n};\r\n","import { Vector2, Texture, Scene, StandardMaterial } from '@babylonjs/core';\r\nimport { textures } from './rexturePack';\r\n\r\nexport interface texturePack {\r\n    [key: string]: { filename: string; corner: Vector2; size: Vector2 };\r\n}\r\n\r\nlet resourceFiles = Object.values(textures).map((texture) => texture.filename);\r\nresourceFiles = resourceFiles.filter((v, i) => resourceFiles.indexOf(v) === i);\r\n\r\nlet atlases: { [key: string]: HTMLImageElement } = {};\r\n\r\nlet loaded = 0;\r\n\r\nexport function loadTextures(onLoad: () => void, onStateChange?: (loaded: number, of: number) => void) {\r\n    resourceFiles.forEach((filename) => {\r\n        atlases[filename] = new Image();\r\n        atlases[filename].onload = () => {\r\n            loaded++;\r\n            onStateChange && onStateChange(loaded, resourceFiles.length);\r\n\r\n            if (loaded === resourceFiles.length) {\r\n                onLoad();\r\n            }\r\n        };\r\n        atlases[filename].onerror = () => {\r\n            console.error('Error loading resource file: ', filename);\r\n        };\r\n        atlases[filename].src = 'resources/' + filename;\r\n    });\r\n\r\n    return resourceFiles.length;\r\n}\r\n\r\nexport const TEXTURE_RESOLUTION = 50;\r\nconst DEFAULT_SCALE = 0.5;\r\n\r\nexport function createTexture(texture: string, scene: Scene) {\r\n    const t = new Texture('resources/' + textures[texture].filename, scene, false, true, Texture.NEAREST_LINEAR);\r\n    t.hasAlpha = true;\r\n    return t;\r\n}\r\n\r\nexport function drawTexture(\r\n    ctx: CanvasRenderingContext2D,\r\n    texture: string,\r\n    x: number,\r\n    y: number,\r\n    width?: number,\r\n    height?: number,\r\n) {\r\n    if (!Object.keys(textures).includes(texture)) {\r\n        console.warn('Texture not found: ', texture);\r\n        return;\r\n    }\r\n\r\n    const imageW = textures[texture].size.x;\r\n    const imageH = textures[texture].size.y;\r\n\r\n    const widthCalculated = width || imageW * DEFAULT_SCALE;\r\n    const heightCalculated = height || (imageH * widthCalculated) / imageW;\r\n\r\n    // ctx.strokeStyle = '#000000';\r\n    // ctx.strokeRect(x, y, widthCalculated, heightCalculated);\r\n\r\n    // console.log(x, y, widthCalculated, heightCalculated);\r\n\r\n    ctx.drawImage(\r\n        atlases[textures[texture].filename],\r\n        textures[texture].corner.x,\r\n        textures[texture].corner.y,\r\n        imageW,\r\n        imageH,\r\n        x,\r\n        y,\r\n        widthCalculated,\r\n        heightCalculated,\r\n    );\r\n}\r\n\r\nexport function createMaterial(texture: Texture, scene: Scene) {\r\n    const material = new StandardMaterial('mat', scene);\r\n    material.emissiveTexture = texture;\r\n    material.opacityTexture = texture;\r\n\r\n    return material;\r\n}","import { Mesh, Vector2, Scene } from '@babylonjs/core';\r\n\r\nexport abstract class AbstractGameObject {\r\n    protected scene: Scene | null = null;\r\n    protected mesh: Mesh | null = null;\r\n    public position: Vector2 = Vector2.Zero();\r\n\r\n    attachBabylon(scene: Scene): AbstractGameObject {\r\n        this.scene = scene;\r\n\r\n        return this;\r\n    }\r\n\r\n    abstract serialize(): any;\r\n\r\n    abstract deserialize(serialized: any): void;\r\n\r\n    tick(deltaTime: number): void {}\r\n\r\n    abstract async updateMesh(): Promise<void>;\r\n\r\n    setVisibility(visible: boolean) {\r\n        if (this.mesh) this.mesh.setEnabled(visible);\r\n    }\r\n\r\n    abstract get id(): string;\r\n}\r\n","import { Vector3, Mesh, Scene, MeshBuilder, DynamicTexture, Texture } from '@babylonjs/core';\r\nimport { createTexture, createMaterial } from '../textures/textureEngine';\r\nimport { AbstractGameObject } from './AbstractGameObject';\r\n\r\nexport interface serializedPlayer {\r\n    x: number;\r\n    y: number;\r\n    velocityX: number;\r\n    velocityY: number;\r\n}\r\n\r\nexport interface keyBindings {\r\n    up: number;\r\n    down: number;\r\n    left: number;\r\n    right: number;\r\n}\r\n\r\nconst SPEED_CHANGE = 0.2;\r\nconst SLOWING = 0.95;\r\nconst MODIFIER = 0.1;\r\nconst SMOOTH_TIME = 50;\r\n\r\nexport class Player extends AbstractGameObject {\r\n    private velocityX: number = 0;\r\n    private velocityY: number = 0;\r\n\r\n    // SMOOTHING\r\n    private targetX: number = 0;\r\n    private targetY: number = 0;\r\n    private finalVelocityX: number = 0;\r\n    private finalVelocityY: number = 0;\r\n    private targetTime: number = -1;\r\n\r\n    private keyBindings: keyBindings = {\r\n        up: 0,\r\n        down: 0,\r\n        left: 0,\r\n        right: 0,\r\n    };\r\n    private keysPressed: number[] = [];\r\n\r\n    constructor(public id: string) {\r\n        super();\r\n    }\r\n\r\n    serialize(): serializedPlayer {\r\n        return {\r\n            x: this.position.x,\r\n            y: this.position.y,\r\n            velocityX: this.velocityX,\r\n            velocityY: this.velocityY,\r\n        };\r\n    }\r\n\r\n    deserialize(serialized: serializedPlayer, smooth?: boolean): void {\r\n        if (smooth) {\r\n            this.targetX = serialized.x;\r\n            this.targetY = serialized.y;\r\n            this.finalVelocityX = serialized.velocityX;\r\n            this.finalVelocityY = serialized.velocityY;\r\n            this.targetTime = SMOOTH_TIME;\r\n            this.velocityX = (serialized.x - this.position.x) / SMOOTH_TIME;\r\n            this.velocityY = (serialized.y - this.position.y) / SMOOTH_TIME;\r\n        } else {\r\n            this.position.x = serialized.x;\r\n            this.position.y = serialized.y;\r\n            this.velocityX = serialized.velocityX;\r\n            this.velocityY = serialized.velocityY;\r\n        }\r\n    }\r\n\r\n    tick(deltaTime: number) {\r\n        if (this.targetTime > 0) {\r\n            this.position.x += this.velocityX * deltaTime;\r\n            this.position.y += this.velocityY * deltaTime;\r\n            this.targetTime -= deltaTime;\r\n\r\n            if (this.targetTime <= 0) {\r\n                this.position.x = this.targetX;\r\n                this.position.y = this.targetY;\r\n                this.velocityX = this.finalVelocityX;\r\n                this.velocityY = this.finalVelocityY;\r\n            }\r\n\r\n            this.updateMesh();\r\n            return;\r\n        }\r\n\r\n        if (!this.keyBindings.up && !this.keyBindings.down && !this.keyBindings.left && !this.keyBindings.right) {\r\n            this.position.x += this.velocityX;\r\n            this.position.y += this.velocityY;\r\n\r\n            this.updateMesh();\r\n            return;\r\n        }\r\n\r\n        const deltaTimeModified = MODIFIER * deltaTime;\r\n\r\n        let movingX = false;\r\n        let movingY = false;\r\n\r\n        const diagonalModifier = Math.sqrt(2);\r\n\r\n        if (this.keysPressed.includes(this.keyBindings.left) || this.keysPressed.includes(this.keyBindings.right)) {\r\n            movingX = true;\r\n        }\r\n        if (this.keysPressed.includes(this.keyBindings.up) || this.keysPressed.includes(this.keyBindings.down)) {\r\n            movingY = true;\r\n        }\r\n\r\n        if (this.keysPressed.includes(this.keyBindings.left)) {\r\n            // Left\r\n            this.velocityX -= (SPEED_CHANGE * deltaTimeModified) / (movingY ? diagonalModifier : 1);\r\n        }\r\n        if (this.keysPressed.includes(this.keyBindings.right)) {\r\n            // Right\r\n            this.velocityX += (SPEED_CHANGE * deltaTimeModified) / (movingY ? diagonalModifier : 1);\r\n        }\r\n        if (this.keysPressed.includes(this.keyBindings.up)) {\r\n            // Up\r\n            this.velocityY -= (SPEED_CHANGE * deltaTimeModified) / (movingX ? diagonalModifier : 1);\r\n        }\r\n        if (this.keysPressed.includes(this.keyBindings.down)) {\r\n            // Down\r\n            this.velocityY += (SPEED_CHANGE * deltaTimeModified) / (movingX ? diagonalModifier : 1);\r\n        }\r\n\r\n        this.position.x += this.velocityX * deltaTimeModified;\r\n        this.position.y += this.velocityY * deltaTimeModified;\r\n\r\n        this.velocityX *= Math.pow(SLOWING, deltaTimeModified);\r\n        this.velocityY *= Math.pow(SLOWING, deltaTimeModified);\r\n\r\n        if (Math.abs(this.velocityX) < 0.1) {\r\n            this.velocityX = 0;\r\n        }\r\n        if (Math.abs(this.velocityY) < 0.1) {\r\n            this.velocityY = 0;\r\n        }\r\n\r\n        this.updateMesh();\r\n    }\r\n\r\n    // ========== CONTROLS ===========\r\n\r\n    keyDown(keyCode: number) {\r\n        if (!this.keysPressed.includes(keyCode)) {\r\n            this.keysPressed.push(keyCode);\r\n        }\r\n    }\r\n\r\n    keyUp(keyCode: number) {\r\n        if (this.keysPressed.includes(keyCode)) {\r\n            this.keysPressed = this.keysPressed.filter((key) => key !== keyCode);\r\n        }\r\n    }\r\n\r\n    bindKeys(newBindings: Partial<keyBindings>) {\r\n        this.keyBindings = { ...this.keyBindings, ...newBindings };\r\n    }\r\n\r\n    // ========== BABYLON ===========\r\n\r\n    attachBabylon(scene: Scene) {\r\n        super.attachBabylon(scene);\r\n\r\n        if (!this.scene) return this;\r\n\r\n        this.mesh = MeshBuilder.CreatePlane(\r\n            'player',\r\n            { width: 60, height: 100, sideOrientation: Mesh.FRONTSIDE },\r\n            this.scene,\r\n        );\r\n        const texture = createTexture('player', this.scene);\r\n        this.mesh.material = createMaterial(texture, this.scene);\r\n\r\n        // Player title\r\n        const title = MeshBuilder.CreatePlane(\r\n            'title',\r\n            { width: 100, height: 20, sideOrientation: Mesh.FRONTSIDE },\r\n            this.scene,\r\n        );\r\n        title.position = new Vector3(0, 60, -3);\r\n        const titleTexture = new DynamicTexture(\r\n            'titleTexture',\r\n            { width: 100, height: 20 },\r\n            this.scene,\r\n            true,\r\n            Texture.NEAREST_LINEAR,\r\n        );\r\n        const ctx = titleTexture.getContext();\r\n        ctx.fillStyle = '#000000AA';\r\n        ctx.fillRect(0, 0, titleTexture.getSize().width, titleTexture.getSize().height);\r\n        ctx.font = '15px Arial';\r\n        ctx.textBaseline = 'middle';\r\n        ctx.textAlign = 'center';\r\n        ctx.fillStyle = '#FFFFFF';\r\n        ctx.fillText(\r\n            this.id,\r\n            titleTexture.getSize().width / 2,\r\n            titleTexture.getSize().height / 2,\r\n            titleTexture.getSize().width - 20,\r\n        );\r\n        titleTexture.update();\r\n\r\n        title.parent = this.mesh;\r\n        title.material = createMaterial(titleTexture, this.scene);\r\n\r\n        this.updateMesh();\r\n\r\n        return this;\r\n    }\r\n\r\n    async updateMesh() {\r\n        if (this.mesh) this.mesh.position = new Vector3(this.position.x, -this.position.y, -1);\r\n    }\r\n}\r\n","import { Vector3, Mesh, Scene, MeshBuilder, StandardMaterial, Texture, DynamicTexture, Vector2 } from '@babylonjs/core';\nimport { AbstractGameObject } from './AbstractGameObject';\n\nexport type tileType = number;\n\nexport interface serializedChunk {\n    x: number;\n    y: number;\n    ground: tileType[][];\n}\n\nexport class Chunk extends AbstractGameObject {\n    ground: tileType[][] = [[]];\n\n    constructor(x: number, y: number) {\n        super();\n        this.position = new Vector2(x, y);\n    }\n\n    get id(): string {\n        return Chunk.getId(this.position.x, this.position.y);\n    }\n\n    serialize(): serializedChunk {\n        return {\n            x: this.position.x,\n            y: this.position.y,\n            ground: this.ground,\n        };\n    }\n\n    deserialize(serialized: serializedChunk): void {\n        this.position.x = serialized.x;\n        this.position.y = serialized.y;\n        this.ground = serialized.ground;\n\n        this.updateMesh();\n    }\n\n    static getId(x: number, y: number): string {\n        return x.toString() + 'x' + y.toString();\n    }\n\n    // ========== BABYLON ===========\n\n    attachBabylon(scene: Scene) {\n        super.attachBabylon(scene);\n\n        this.mesh = MeshBuilder.CreatePlane(\n            'chunk',\n            { width: 1600, height: 1600, sideOrientation: Mesh.FRONTSIDE },\n            this.scene,\n        );\n        this.updateMesh();\n\n        return this;\n    }\n\n    async updateMesh() {\n        if (!this.mesh || !this.scene) {\n            return;\n        }\n\n        this.mesh.position = new Vector3(this.position.x * 16 * 100, -this.position.y * 16 * 100, 0);\n\n        const texture = new DynamicTexture(\n            'chunkTexture',\n            { width: 1 * 16, height: 1 * 16 },\n            this.scene,\n            true,\n            Texture.NEAREST_NEAREST,\n        );\n\n        const ctx = texture.getContext();\n\n        for (let x = 0; x < 16; x++) {\n            for (let y = 0; y < 16; y++) {\n                if (this.ground[x] && this.ground[x][y]) {\n                    ctx.fillStyle = Chunk.getTerrainColor(this.ground[x][y]);\n\n                    ctx.fillRect(x, y, 1, 1);\n                    if ((x + y) % 2 === 0) {\n                        ctx.fillStyle = '#00000005';\n                        ctx.fillRect(x, y, 1, 1);\n                    }\n                }\n            }\n        }\n\n        texture.update();\n\n        const material = new StandardMaterial('mat', this.scene);\n        material.emissiveTexture = texture;\n        this.mesh.material = material;\n    }\n\n    static getTerrainColor(number: number): string {\n        switch (number) {\n            case 1: // Grass\n                return '#CFDA78';\n            case 2: // Water\n                return '#4EDCF0';\n            case 3: // Forrest\n                return '#6AA981';\n            case 4: // Sand\n                return '#FDDC86';\n        }\n        return '#DDDDDD';\n    }\n}\n","import { Player } from './gameObjects/Player';\r\nimport { Chunk } from './gameObjects/Chunk';\r\n\r\nexport class GameScene {\r\n    players = new IndexedList<Player>();\r\n    chunks = new IndexedList<Chunk>();\r\n\r\n    tickAll(deltaTime: number) {\r\n        this.players.forEach((value) => value.tick(deltaTime));\r\n        this.chunks.forEach((value) => value.tick(deltaTime));\r\n    }\r\n}\r\n\r\nclass IndexedList<T extends Player | Chunk> {\r\n    values: { [key: string]: T } = {};\r\n\r\n    add(key: string, value: T) {\r\n        this.values[key] = value;\r\n    }\r\n\r\n    remove(key: string) {\r\n        if (!this.includes(key)) return;\r\n        delete this.values[key];\r\n    }\r\n\r\n    update(key: string, serialized: any, smooth?: boolean) {\r\n        this.values[key].deserialize(serialized, smooth);\r\n    }\r\n\r\n    updateOrCreate(key: string, serialized: any, newObjectCreator: () => T, smooth?: boolean) {\r\n        if (!this.includes(key)) {\r\n            this.values[key] = newObjectCreator();\r\n        }\r\n        this.values[key].deserialize(serialized, smooth);\r\n    }\r\n\r\n    get(key: string) {\r\n        if (!this.includes(key)) return null;\r\n        return this.values[key];\r\n    }\r\n\r\n    includes(key: string) {\r\n        return Object.keys(this.values).includes(key);\r\n    }\r\n\r\n    forEach(callbackfn: (value: T, key: string, index: number) => void) {\r\n        const keys = Object.keys(this.values);\r\n\r\n        keys.forEach((key, index) => {\r\n            callbackfn(this.values[key], key, index);\r\n        });\r\n    }\r\n\r\n    filter(callbackfn: (value: T, key: string, index: number) => boolean) {\r\n        const keys = Object.keys(this.values);\r\n\r\n        let result = Object.assign({}, this.values);\r\n\r\n        keys.forEach((key, index) => {\r\n            if (!callbackfn(this.values[key], key, index)) {\r\n                delete result[key];\r\n            }\r\n        });\r\n\r\n        return result;\r\n    }\r\n}\r\n","import { keyBindings } from './gameMechanics/gameObjects/Player';\r\n\r\n// ARROWS\r\nexport const CONTROLS_ARROWS: keyBindings = {\r\n    left: 37,\r\n    right: 39,\r\n    up: 38,\r\n    down: 40,\r\n};\r\n\r\n// WASD\r\nexport const CONTROLS_WASD: keyBindings = {\r\n    left: 65,\r\n    right: 68,\r\n    up: 87,\r\n    down: 83,\r\n};\r\n","import io from 'socket.io-client';\r\nimport { Player } from '../gameObjects/Player';\r\nimport { GameScene } from '../Scene';\r\nimport { messagePlayers } from '../../messageTypes';\r\nimport babylonjs from '@babylonjs/core';\r\nimport { serializedChunk, Chunk } from '../gameObjects/Chunk';\r\n\r\ntype callback = (data: any) => void;\r\n\r\nexport class NetworkClient {\r\n    private socket: SocketIOClient.Socket;\r\n    private userId: string;\r\n    private opened: boolean;\r\n    private callbacks: { [key: string]: callback } = {\r\n        authenticated: () => {},\r\n        updated: () => {},\r\n    };\r\n\r\n    constructor(private apiUrl: string, private scene: GameScene, private getBabylonScene: () => babylonjs.Scene) {}\r\n\r\n    public on(event: 'authenticated' | 'updated', callback: callback) {\r\n        this.callbacks[event] = callback;\r\n    }\r\n\r\n    public close() {\r\n        this.socket.disconnect();\r\n    }\r\n\r\n    public open() {\r\n        this.opened = true;\r\n        this.socket = io(this.apiUrl);\r\n        this.setListeners();\r\n\r\n        this.socket.on('id', (data: string) => {\r\n            this.userId = data;\r\n            this.callbacks['authenticated']({ id: data });\r\n            console.log('Joined game with player ID: ', data);\r\n        });\r\n    }\r\n\r\n    public sendPlayerUpdate(player: Player) {\r\n        this.socket.emit('update', { id: player.id, content: player.serialize() });\r\n    }\r\n\r\n    public requestChunk(x: number, y: number) {\r\n        this.socket.emit('mapRequest', { x, y });\r\n    }\r\n\r\n    private setListeners() {\r\n        this.socket.on('players', (data: messagePlayers) => {\r\n            this.scene.players.forEach((player, key) => {\r\n                if (!Object.keys(data).includes(key)) {\r\n                    this.scene.players.get(key)!.setVisibility(false);\r\n                } else {\r\n                    this.scene.players.get(key)!.setVisibility(true);\r\n                }\r\n            });\r\n\r\n            Object.keys(data).forEach((key) => {\r\n                if (key === this.userId) {\r\n                    return;\r\n                }\r\n\r\n                this.scene.players.updateOrCreate(key, data[key], () =>\r\n                    new Player(key).attachBabylon(this.getBabylonScene()),\r\n                );\r\n            });\r\n        });\r\n\r\n        this.socket.on('mapChunk', (data: serializedChunk) => {\r\n            const id = Chunk.getId(data.x, data.y);\r\n\r\n            this.scene.chunks.updateOrCreate(id, data, () =>\r\n                new Chunk(data.x, data.y).attachBabylon(this.getBabylonScene()),\r\n            );\r\n            // TODO: throw away unused chunks\r\n        });\r\n    }\r\n}\r\n","import { Chunk } from '../gameObjects/Chunk';\nimport { AdvancedDynamicTexture } from '@babylonjs/gui/2D/advancedDynamicTexture';\nimport { GameScene } from '../Scene';\nimport { Player } from '../gameObjects/Player';\n\nconst MINIMAP_DISTANCE = 32;\nconst MINIMAP_SCALE = 2;\nconst BORDER_WIDTH = 3;\n\nexport function minimap(guiTexture: AdvancedDynamicTexture, gameScene: GameScene, me: Player) {\n    const gui = guiTexture.getContext();\n    const width = guiTexture.getSize().width;\n    const height = guiTexture.getSize().height;\n\n    const x0 = width - 30 - MINIMAP_SCALE * MINIMAP_DISTANCE;\n    const y0 = 20 + MINIMAP_SCALE * MINIMAP_DISTANCE;\n\n    gui.fillStyle = '#000000';\n    gui.fillRect(\n        x0 - MINIMAP_SCALE * MINIMAP_DISTANCE - BORDER_WIDTH,\n        y0 - MINIMAP_SCALE * MINIMAP_DISTANCE - BORDER_WIDTH,\n        MINIMAP_SCALE * MINIMAP_DISTANCE * 2 + BORDER_WIDTH * 2 + MINIMAP_SCALE,\n        MINIMAP_SCALE * MINIMAP_DISTANCE * 2 + BORDER_WIDTH * 2 + MINIMAP_SCALE,\n    );\n\n    for (let x = -MINIMAP_DISTANCE; x <= MINIMAP_DISTANCE; x++) {\n        for (let y = -MINIMAP_DISTANCE; y <= MINIMAP_DISTANCE; y++) {\n            gui.fillStyle = Chunk.getTerrainColor(getTile(me.position.x / 100 + x, me.position.y / 100 + y, gameScene));\n            gui.fillRect(x0 + x * MINIMAP_SCALE, y0 + y * MINIMAP_SCALE, MINIMAP_SCALE, MINIMAP_SCALE);\n        }\n    }\n\n    gui.fillStyle = \"#000000\";\n    gui.font = '15px Arial';\n    gui.textBaseline = 'top';\n    gui.textAlign = 'center';\n    gui.fillText(\n        me\n            ? Math.round(me.position.x / 100) + ' × ' + Math.round(me.position.y / 100)\n            : 'Not connected...',\n        x0,\n        y0 + MINIMAP_SCALE * MINIMAP_DISTANCE + BORDER_WIDTH + 10,\n    );\n    \n    gui.fillStyle = \"#00000020\";\n    gui.fillRect(x0 - MINIMAP_SCALE * 3, y0, MINIMAP_SCALE * 7, MINIMAP_SCALE);\n    gui.fillRect(x0, y0 - MINIMAP_SCALE * 3, MINIMAP_SCALE, MINIMAP_SCALE * 7);\n\n    guiTexture.update();\n}\n\nfunction getTile(x: number, y: number, scene: GameScene) {\n    const calcX = Math.floor(x) + 8;\n    const calcY = Math.floor(y) + 8;\n\n    const chunkX = Math.floor(calcX / 16);\n    const chunkY = Math.floor(calcY / 16);\n    const chunk = scene.chunks.get(Chunk.getId(chunkX, chunkY));\n\n    if (!chunk || !chunk.ground[calcX - chunkX * 16] || !chunk.ground[calcX - chunkX * 16][calcY - chunkY * 16]) {\n        return -1;\n    }\n\n    return chunk.ground[calcX - chunkX * 16][calcY - chunkY * 16];\n}","import React from 'react';\n\nimport '@babylonjs/core/Physics/physicsEngineComponent';\nimport babylonjs, { Vector3, UniversalCamera, Texture } from '@babylonjs/core';\nimport { Scene, Engine, SceneEventArgs } from 'react-babylonjs';\n\nimport { AdvancedDynamicTexture } from '@babylonjs/gui/2D/advancedDynamicTexture';\nimport { Player } from './gameObjects/Player';\nimport { Chunk } from './gameObjects/Chunk';\nimport { GameScene } from './Scene';\nimport { CONTROLS_WASD } from '../keyBindings';\nimport { NetworkClient } from './network/NetworkClient';\nimport { minimap } from './gui/minimap';\n\nconst Z_DISTANCE = 1500;\nconst RENDER_DISTANCE = 2;\n\ninterface IGameCoreProps {\n    apiUrl: string;\n}\n\ninterface IGameCoreState {}\n\nexport class GameCore extends React.Component<IGameCoreProps, IGameCoreState> {\n    gameScene: GameScene;\n    me: Player | null = null;\n\n    babylonScene: babylonjs.Scene | null;\n    guiTexture: AdvancedDynamicTexture | null;\n    networkClient: NetworkClient;\n    state: IGameCoreState = {};\n\n    timer: NodeJS.Timeout;\n\n    constructor(props: IGameCoreProps) {\n        super(props);\n\n        this.gameScene = new GameScene();\n        this.networkClient = new NetworkClient(this.props.apiUrl, this.gameScene, () => this.babylonScene!);\n        this.networkClient.on('authenticated', (data: { id: string }) => this.initGame(data.id));\n\n        document.addEventListener('keydown', (event) => {\n            if (this.me) {\n                this.me.keyDown(event.keyCode);\n            }\n        });\n\n        document.addEventListener('keyup', (event) => {\n            if (this.me) {\n                this.me.keyUp(event.keyCode);\n            }\n        });\n\n        window.addEventListener('resize', (event) => {\n            this.resize();\n        });\n    }\n\n    componentDidMount() {\n        this.resize();\n        this.networkClient.open();\n    }\n\n    componentWillUnmount() {\n        clearInterval(this.timer);\n        this.networkClient.close();\n    }\n\n    initGame(id: string) {\n        this.me = new Player(id);\n        this.me.attachBabylon(this.babylonScene!);\n        this.me.bindKeys(CONTROLS_WASD);\n        this.gameScene.players.add(id, this.me);\n\n        (window as any).player = this.me;\n        (window as any).scene = this.gameScene;\n\n        this.timer = setInterval(() => {\n            if (this.me) this.networkClient.sendPlayerUpdate(this.me);\n        }, 100);\n    }\n\n    tick(deltaTime: number) {\n        this.gameScene.players.forEach((player) => player.tick(deltaTime));\n\n        this.gameScene.chunks.forEach((chunk) => chunk.setVisibility(false));\n\n        if (this.me && this.guiTexture) {\n            for (let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {\n                for (let y = -RENDER_DISTANCE; y <= RENDER_DISTANCE; y++) {\n                    const chunkX = Math.round(this.me.position.x / 1600) + x;\n                    const chunkY = Math.round(this.me.position.y / 1600) + y;\n                    const chunkId = Chunk.getId(chunkX, chunkY);\n\n                    if (this.gameScene.chunks.includes(chunkId)) {\n                        this.gameScene.chunks.get(chunkId)!.setVisibility(true);\n                    } else {\n                        this.networkClient.requestChunk(chunkX, chunkY);\n                        this.gameScene.chunks.add(chunkId, new Chunk(chunkX, chunkY).attachBabylon(this.babylonScene!));\n                    }\n                }\n            }\n\n            const gui = this.guiTexture.getContext();\n            const width = this.guiTexture.getSize().width;\n            const height = this.guiTexture.getSize().height;\n            gui.clearRect(0, 0, width, height);\n\n            minimap(this.guiTexture, this.gameScene, this.me);\n\n            this.guiTexture.update();\n        }\n    }\n\n    resize() {\n        const canvas = document.getElementById('game') as HTMLCanvasElement;\n        if (canvas) {\n            canvas.width = window.innerWidth;\n            canvas.height = window.innerHeight;\n        }\n    }\n\n    onSceneMount(event: SceneEventArgs) {\n        const { scene } = event;\n\n        this.babylonScene = scene;\n\n        const camera = new UniversalCamera('Camera', new Vector3(0, 0, Z_DISTANCE), scene);\n        camera.rotation = new Vector3(0, 0, 0);\n        //camera.attachControl(event.canvas, true);\n\n        this.guiTexture = AdvancedDynamicTexture.CreateFullscreenUI('GUI', true, scene);\n\n        scene.getEngine().runRenderLoop(() => {\n            this.tick(scene.getEngine().getDeltaTime());\n\n            if (this.me) {\n                camera.position = new Vector3(this.me.position.x, -this.me.position.y, -Z_DISTANCE);\n            }\n\n            if (scene) {\n                scene.render();\n            }\n        });\n    }\n\n    render() {\n        return (\n            <>\n                <Engine antialias={true} canvasId=\"game\">\n                    <Scene onSceneMount={(event: SceneEventArgs) => this.onSceneMount(event)}>\n                        <></>\n                    </Scene>\n                </Engine>\n            </>\n        );\n    }\n}\n","import React from 'react';\r\nimport { GameCore } from './gameMechanics/GameCore';\r\nimport { loadTextures } from './gameMechanics/textures/textureEngine';\r\n\r\ninterface IAppProps {}\r\n\r\ninterface IAppState {\r\n    status: 'loading' | 'menu' | 'paused' | 'ingame';\r\n    textures: {\r\n        loaded: number;\r\n        of: number;\r\n    };\r\n}\r\n\r\nclass App extends React.Component<IAppProps, IAppState> {\r\n    //apiUrl = 'http://localhost:80/';\r\n    apiUrl = 'https://randombot-server.herokuapp.com/';\r\n\r\n    state: IAppState = {\r\n        status: 'loading',\r\n        textures: {\r\n            loaded: 0,\r\n            of: 0,\r\n        },\r\n    };\r\n\r\n    componentDidMount() {\r\n        this.setState({\r\n            textures: {\r\n                loaded: 0,\r\n                of: loadTextures(\r\n                    () => {\r\n                        this.setState({ status: 'ingame' });\r\n                    },\r\n                    (loaded, of) => {\r\n                        this.setState({\r\n                            textures: {\r\n                                loaded,\r\n                                of,\r\n                            },\r\n                        });\r\n                    },\r\n                ),\r\n            },\r\n        });\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <>\r\n                {this.state.status === 'loading' && (\r\n                    <div style={{ textAlign: 'center' }}>\r\n                        Textures are loading ({this.state.textures.loaded}/{this.state.textures.of})\r\n                    </div>\r\n                )}\r\n                {this.state.status === 'ingame' && <GameCore apiUrl={this.apiUrl} />}\r\n            </>\r\n        );\r\n    }\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}